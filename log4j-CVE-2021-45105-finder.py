#!/usr/bin/env python

"""
twitter: @secursive
github: github.com/secursive

CVE: CVE-2021-45105

Script to find potentially vulnerable patterns in log4j configuration.
*** No warranty of any kind. Run at your own risk ***

References:
https://nvd.nist.gov/vuln/detail/CVE-2021-45105
https://issues.apache.org/jira/browse/LOG4J2-3230
https://twitter.com/pwntester/status/1471511483422961669
https://logging.apache.org/log4j/2.x/security.html

NOTES:
1. In some cases, you might see a variable such as $pattern or $log_pattern etc. In those cases, look for property variable in same file on top for actual pattern string, e.g. property.pattern or property.log_pattern.
2. The script assumes that default filenames e.g. log4j.properties, log4j2.xml etc are used. You should check in ps output to ensure that log4j2.configuration, log4j.configuration, log4j2.configurationFile, log4j.configurationFile is not set to a different style named file.
3. Output of script shows potentially dangerous patterns that need further evaluation to confirm vulnerability. Only if there are variables/parameters coming from user request would it be exploitable.

From log4j documentation, I have identified following different styles for pattern specs.

# => XML
# <PatternLayout pattern="%m%n"/>
# and
# 
# <PatternLayout>
#	 <pattern>%m%n</pattern>
# </PatternLayout>
#
#<param name="ConversionPattern" value="%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n" />

# => JSON
#"PatternLayout": { "pattern": "%m%n" },

# => YAML
#		PatternLayout:
#		Pattern: "%m%n"

# => PROPERTIES
#*.pattern = %m%n
#*.ConversionPattern = %m%n


"""

import os
from defusedxml.ElementTree import parse
import json
import yaml
import re
from itertools import chain

SCRIPT_VERSION = "1.1"

def find_by_key(data, target):
	for key, value in data.items():
		if isinstance(value, dict):
			yield from find_by_key(value, target)
		elif key.lower() == target.lower():
			yield value

def process_log4j_conf_properties(fpath):
	lno = 0
	with open(fpath, 'r') as f:
		lines = f.readlines()
		for line in lines:
			lno = lno + 1
			ls = line.split("=", 1)
			if len(ls) > 1:
				l1 = ls[0].strip().lower()
				l2 = ls[1].strip()
				if l1.endswith((".pattern", ".conversionpattern")):
					if "$" in l2:
						print("	 => [DANGEROUS] Line {}: {}".format(lno, line.strip()))
					else:
						print("	 => [safe] Line {} : {}".format(lno, line.strip()))

def process_log4j_conf_xml(fpath):
	with open(fpath, 'r') as f:
		content = parse(f)
		nodes = content.findall(".//PatternLayout")
		for n in nodes:
			if "pattern" in n.attrib:
				v = (n.attrib["pattern"])
				if "$" in v:
					print("	 => [DANGEROUS] <PatternLayout pattern= {}".format(v.strip()))
				else:
					print("	 => [safe] <PatternLayout pattern= {}".format(v.strip()))
		nodes = content.findall(".//pattern")
		for n in nodes:
			v = n.text
			if "$" in v:
				print("	 => [DANGEROUS] <pattern> {}".format(v.strip()))
			else:
				print("	 => [safe] <pattern> {}".format(v.strip()))
		nodes = content.findall(".//Pattern")
		for n in nodes:
			v = n.text
			if "$" in v:
				print("	 => [DANGEROUS] <pattern> {}".format(v.strip()))
			else:
				print("	 => [safe] <pattern> {}".format(v.strip()))
		nodes = content.findall(".//param")
		for n in nodes:
			if n.attrib("name").lower() == "conversionpattern":
				v = (n.attrib["value"])
				if "$" in v:
					print("	 => [DANGEROUS] <param name=ConversionPattern value= {}".format(v.strip()))
				else:
					print("	 => [safe]  <param name=ConversionPattern value= {}".format(v.strip()))

def process_log4j_conf_json(fpath):
	with open(fpath, 'r') as f:
		content = json.load(f)
		for v in find_by_key(content, "pattern"):
			if "$" in v:
				print("	 => [DANGEROUS] pattern: {}".format(v.strip()))
			else:
				print("	 => [safe] pattern: {}".format(v.strip()))
		for v in find_by_key(content, "conversionpattern"):
			if "$" in v:
				print("	 => [DANGEROUS] conversionpattern: {}".format(v.strip()))
			else:
				print("	 => [safe] conversionpattern: {}".format(v.strip()))

def process_log4j_conf_yaml(fpath):
	with open(fpath, 'r') as f:
		content = yaml.safe_load(f)
		for v in find_by_key(content, "Pattern"):
			if "$" in v:
				print("	 => [DANGEROUS] Pattern: {}".format(v.strip()))
			else:
				print("	 => [safe] Pattern: {}".format(v.strip()))
		for v in find_by_key(content, "ConversionPattern"):
			if "$" in v:
				print("	 => [DANGEROUS] ConversionPattern: {}".format(v.strip()))
			else:
				print("	 => [safe] ConversionPattern: {}".format(v.strip()))

def process_log4j_conf(root, file_name):
	fpath = os.path.join(root, file_name)
	print("[{}]".format(os.path.join(root, fpath)))
	try:
		if file_name.endswith("properties"):
			process_log4j_conf_properties(fpath)
		elif file_name.endswith("xml"):
			process_log4j_conf_xml(fpath)
		elif file_name.endswith("json"):
			process_log4j_conf_json(fpath)
		elif file_name.endswith(("yaml", "yml")):
			process_log4j_conf_yaml(fpath)
		else:
			print("	 => [ERROR] Not a supported log4j configuration file type")
	except Exception as e:
		print("	 => [ERROR] Exception raised while processing file. Please share this file with @secursive on twitter for script improvement.")
	print()

def is_log4j_conf(file_name):
	if file_name.startswith("log4j"):
		if file_name.endswith(("properties", "xml", "json", "yaml", "yml")):
			return True
	return False

def main():
	print()
	for root, _, files in chain.from_iterable(os.walk(path) for path in ["/"]):
		for file_name in files:
			if is_log4j_conf(file_name):
				process_log4j_conf(root, file_name)

if __name__ == '__main__':
	main()
